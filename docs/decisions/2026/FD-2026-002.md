_**[APPROVED DRAFT]**_

# FD-2026-002: Transaction Queue Persistence

**Status:** Ratified
**Ratified:** 2026-02-02
**Replaces:** None

---

## 1. Mandate

This Founder Decision (FD) establishes the formal specification for the persistence of offline transactions within the WebWaka Agentic Software Factory. All client-side applications must adhere to this specification to ensure data integrity, durability, and a consistent user experience during periods of network disconnection.

## 2. Specification

### 2.1. Storage Mechanism

The underlying storage mechanism for the transaction queue is platform-dependent to leverage native optimizations, but must conform to a unified logical model.

| Platform | Technology  | Notes                                                              |
| :------- | :---------- | :----------------------------------------------------------------- |
| Web      | IndexedDB   | Standard asynchronous API for client-side storage in web browsers. |
| Mobile   | SQLite      | Robust, transactional SQL database engine for native mobile applications. |

### 2.2. Data Structure

Each entry in the transaction queue must be a structured record containing the following fields. This ensures that all necessary information for processing, debugging, and synchronization is available.

| Field             | Type     | Description                                                                 |
| :---------------- | :------- | :-------------------------------------------------------------------------- |
| `transaction_id`  | UUID     | A client-generated unique identifier (UUID v4) for the transaction.         |
| `created_at`      | ISO-8601 | The timestamp when the transaction was created.                             |
| `operation_type`  | ENUM     | The type of operation: `CREATE`, `UPDATE`, `DELETE`, or `COMMAND`.          |
| `entity_type`     | String   | The type of the entity being modified (e.g., "document", "task").           |
| `entity_id`       | String   | The unique identifier of the entity being modified.                         |
| `payload`         | JSON     | An immutable JSON object containing the data for the operation.             |
| `status`          | ENUM     | The current status of the transaction: `PENDING`, `IN_PROGRESS`, `SUCCEEDED`, `FAILED`, `DEAD_LETTER`. |
| `retry_count`     | Integer  | The number of times a retry has been attempted.                             |
| `last_attempt_at` | ISO-8601 | The timestamp of the last attempt to process the transaction.               |
| `error_code`      | String   | A nullable error code if the transaction failed.                            |
| `error_message`   | String   | A nullable, human-readable error message if the transaction failed.         |
| `client_version`  | String   | The version of the client application that created the transaction.         |
| `schema_version`  | String   | The schema version of the payload.                                          |

### 2.3. Persistence Requirements

The transaction queue must be durable and reliable, with the following persistence requirements:

*   **Longevity:** Transactions must be persisted until they are successfully synchronized with the server and acknowledged, or until they are explicitly moved to a dead-letter queue. No Time-To-Live (TTL) is applied by default.
*   **Queue Size:** The maximum size of the transaction queue is **10,000** transactions. If the queue exceeds this limit, the oldest `PENDING` transaction may be moved to the `DEAD_LETTER` queue to make space for new transactions.
*   **Cleanup:** `SUCCEEDED` transactions are automatically removed from the queue upon receiving a successful acknowledgment from the server.

### 2.4. Transaction Lifecycle

The lifecycle of a transaction is governed by a state machine that ensures predictable behavior.

*   **States:** `PENDING` → `IN_PROGRESS` → `SUCCEEDED` | `FAILED` → `DEAD_LETTER`
*   **Retries:** `FAILED` transactions are automatically retried according to the logic defined in FD-2026-003.
*   **Dead Lettering:** Transactions that have exhausted their retry attempts are moved to the `DEAD_LETTER` state and require user or system intervention.
*   **Completion:** A transaction is considered complete only when it has been acknowledged as `SUCCEEDED` by the server.

### 2.5. Durability Guarantees

The transaction queue must provide strong durability guarantees to prevent data loss.

*   **Crash Resistance:** Transactions must survive application crashes and restarts.
*   **Power Loss:** Transactions must survive device power loss.
*   **Atomicity:** Writes to the transaction queue must be atomic. Partial or corrupted transaction records are not permitted.

## 3. Enforcement

Compliance with this specification will be enforced through a combination of automated testing and manual code reviews. Any deviation from this mandate must be justified and approved by the Founder via a formal exception process.
